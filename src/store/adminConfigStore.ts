import { create } from 'zustand';
import { ref, onValue, set as firebaseSet, update as firebaseUpdate, push, remove, get as firebaseGet, Unsubscribe } from 'firebase/database';
import { database, auth } from '../config/firebase';
import { TextObject, ImageObject, DrawObject, FloorImage, Settings, AdminSettings, ViewSettings } from '../types';
import { validateFirebaseUpdate } from '../utils/validation';
import { lwwUpdateTextObject, lwwUpdateImageObject, getCurrentSessionId } from '../utils/lww';
// import { lwwCreateDrawObject } from '../utils/lww'; // ÌòÑÏû¨ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå

export interface AdminConfigStore {
  textObjects: TextObject[];
  imageObjects: ImageObject[];
  drawObjects: DrawObject[];
  floorImage: FloorImage | null;
  settings: Settings;
  isLoading: boolean;
  // Sync metadata
  serverRev: number;
  localRev: number;
  sessionId: string;
  pendingBarrier: boolean;
  lastFlushPromise: Promise<void> | null;
  
  // Firebase ÎèôÍ∏∞Ìôî
  initializeFirebaseListeners: () => void;
  cleanupFirebaseListeners: () => void;
  // Barriered flush of document state with optional snapshot creation
  flushDocumentState: (createSnapshot?: boolean, onSnapshotCreated?: () => void, skipFirebaseSync?: boolean) => Promise<void>;
  
  // TextObject Í¥ÄÎ¶¨
  addTextObject: (obj: Omit<TextObject, 'id'>) => Promise<string>;
  addTextObjects: (objects: Omit<TextObject, 'id'>[]) => Promise<string[]>;
  updateTextObject: (id: string, updates: Partial<TextObject>) => Promise<void>;
  updateTextObjectsBatch: (updatesById: Record<string, Partial<TextObject>>) => Promise<void>;
  deleteTextObject: (id: string) => Promise<void>;
  deleteTextObjects: (ids: string[]) => Promise<void>;
  
  // ImageObject Í¥ÄÎ¶¨
  addImageObject: (obj: Omit<ImageObject, 'id'>) => Promise<string>;
  updateImageObject: (id: string, updates: Partial<ImageObject>) => Promise<void>;
  deleteImageObject: (id: string) => Promise<void>;
  deleteImageObjects: (ids: string[]) => Promise<void>;
  
  // DrawObject Í¥ÄÎ¶¨ (ViewPageÏóêÏÑúÎßå ÏÉùÏÑ±, Ïó¨Í∏∞ÏÑúÎäî ÎèôÍ∏∞ÌôîÎßå)
  deleteDrawObject: (id: string) => Promise<void>;
  
  // FloorImage Í¥ÄÎ¶¨
  setFloorImage: (image: FloorImage) => Promise<void>;
  
  // Settings Í¥ÄÎ¶¨
  updateSettings: (section: 'admin' | 'view', updates: Partial<AdminSettings | ViewSettings>) => Promise<void>;
  
  // Ìå®Ïä§ÏõåÎìú Í¥ÄÎ¶¨
  initializePasswords: () => Promise<void>;
  updatePassword: (type: 'admin' | 'view', newPassword: string) => Promise<void>;
  getPassword: (type: 'admin' | 'view') => string;
}

export const useAdminConfigStore = create<AdminConfigStore>((set, get) => {
  // Firebase Î¶¨Ïä§ÎÑà Ìï¥Ï†ú Ìï®ÏàòÎì§ÏùÑ Ï†ÄÏû•Ìï† Î∞∞Ïó¥
  let unsubscribeFunctions: Unsubscribe[] = [];

  return {
    textObjects: [],
    imageObjects: [],
    drawObjects: [],
    floorImage: null,
    settings: {
      admin: {
        autoToolSwitch: true,
        gridVisible: true,
        gridSize: 16,
        gridSnapEnabled: true,
        defaultFontSize: 16,
        defaultBoxWidth: 200,
        defaultBoxHeight: 60,
        objectCreationPosition: {
          x: 260,
          y: 950
        },
        defaultCheckboxSettings: {
          checkedColor: '#22c55e',
          uncheckedColor: '#f3f4f6',
          checkedBackgroundColor: '#ffffff',
          uncheckedBackgroundColor: '#ffffff',
          checkedBackgroundOpacity: 1,
          uncheckedBackgroundOpacity: 1
        },
        excelPasteSettings: {
          startPosition: { x: 100, y: 100 },
          cellWidth: 120,
          cellHeight: 40,
          fontSize: 32, // Í∏∞Î≥∏ Ìè∞Ìä∏ ÌÅ¨Í∏∞ 32Î°ú Î≥ÄÍ≤Ω
          fontColor: '#000000',
          backgroundColor: 'transparent', // Î∞∞Í≤Ω ÏóÜÏùåÏúºÎ°ú Î≥ÄÍ≤Ω
          maxRows: 50,
          maxCols: 50
        },
        passwords: {
          admin: '1004',
          view: '1004'
        }
      },
      view: {
        virtualKeyboardEnabled: true,
        touchMode: true,
        usePerfectFreehand: true, // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú perfect-freehand ÏÇ¨Ïö©
      }
    },
    isLoading: false,
    serverRev: 0,
    localRev: 0,
    sessionId: getCurrentSessionId(),
    pendingBarrier: false,
    lastFlushPromise: null,
    
    initializeFirebaseListeners: () => {
      // Í∏∞Ï°¥ Î¶¨Ïä§ÎÑàÎì§ Ï†ïÎ¶¨
      get().cleanupFirebaseListeners();
      
      set({ isLoading: true });
      
      let loadedCount = 0;
      const totalLoaders = 5; // textObjects, imageObjects, drawObjects, floorImage, settings
      
      const checkAllLoaded = () => {
        loadedCount++;
        if (import.meta.env.DEV) {
          console.log(`üî• Firebase: Loaded ${loadedCount}/${totalLoaders} data types`);
        }
        if (loadedCount >= totalLoaders) {
          if (import.meta.env.DEV) {
            console.log('üî• Firebase: All data loaded successfully');
          }
          set({ isLoading: false });
        }
      };

      // ÏÑ±Í≥µ/Ïã§Ìå® Ïπ¥Ïö¥ÌÑ∞ Î∂ÑÎ¶¨
      let successCount = 0;
      let errorCount = 0;
      
      const checkSuccess = () => {
        successCount++;
        checkAllLoaded();
      };
      
      const checkError = (source: string, error: any) => {
        errorCount++;
        if (import.meta.env.DEV) {
          console.error(`‚ùå Firebase: ${source} Î°úÎìú Ïã§Ìå®:`, error);
        }
        checkAllLoaded();
      };

      // Firebase Auth ÏÉÅÌÉú ÏÉÅÏÑ∏ ÌôïÏù∏
      if (import.meta.env.DEV) {
        console.log('üîç Firebase: Initializing listeners with auth state:', {
          currentUser: auth.currentUser?.uid,
          isAnonymous: auth.currentUser?.isAnonymous,
          authToken: auth.currentUser ? 'EXISTS' : 'NULL',
          authReady: !!auth.currentUser
        });
        
        // Ïù∏Ï¶ù ÌÜ†ÌÅ∞ Ï∂îÍ∞Ä Í≤ÄÏ¶ù
        if (auth.currentUser) {
          auth.currentUser.getIdToken().then(token => {
            console.log('üîë Firebase: Auth token acquired:', token ? 'SUCCESS' : 'FAILED');
          }).catch(error => {
            console.error('‚ùå Firebase: Token acquisition failed:', error);
          });
        } else {
          console.error('‚ùå Firebase: No authenticated user found when initializing listeners');
        }
      }
      
      // Meta Î¶¨Ïä§ÎÑà (rev/session)
      const metaRef = ref(database, 'meta');
      const unsubscribeMeta = onValue(metaRef, (snapshot) => {
        const meta = snapshot.val() as any || {};
        const incomingRev = Number(meta.rev || 0);
        const incomingSession = meta.sessionId as string | undefined;
        set({ serverRev: incomingRev });
        if (import.meta.env.DEV) {
          console.log('üîÅ Meta updated:', { incomingRev, incomingSession });
        }
      }, (error) => {
        checkError('Meta', error);
      });
      unsubscribeFunctions.push(unsubscribeMeta);

      // TextObjects Î¶¨Ïä§ÎÑà
      const textObjectsRef = ref(database, 'textObjects');
      const unsubscribeTextObjects = onValue(textObjectsRef, (snapshot) => {
        // Listener guard: ignore only during barrier
        const { pendingBarrier } = get();
        if (pendingBarrier) {
          if (import.meta.env.DEV) {
            console.log(`üö´ TextObjects Î¶¨Ïä§ÎÑà: pendingBarrierÎ°ú Ïù∏Ìïú Î¨¥Ïãú`);
          }
          return;
        }
        const data = snapshot.val();
        const textObjects = data ? Object.values(data) as TextObject[] : [];
        if (import.meta.env.DEV) {
          console.log(`üìù Loaded ${textObjects.length} text objects`);
          // Excel Í∑∏Î£πÎ≥ÑÎ°ú Î°úÍπÖ
          const excelGroups = textObjects.filter(obj => obj.groupId?.startsWith('excel-input-'));
          const groupStats = excelGroups.reduce((acc, obj) => {
            acc[obj.groupId!] = (acc[obj.groupId!] || 0) + 1;
            return acc;
          }, {} as Record<string, number>);
          console.log(`üìä Excel groups:`, groupStats);
        }
        set({ textObjects });
        checkSuccess();
      }, (error) => {
        checkError('TextObjects', error);
      });
      unsubscribeFunctions.push(unsubscribeTextObjects);
      
      // ImageObjects Î¶¨Ïä§ÎÑà
      const imageObjectsRef = ref(database, 'imageObjects');
      const unsubscribeImageObjects = onValue(imageObjectsRef, (snapshot) => {
        const { pendingBarrier } = get();
        if (pendingBarrier) return;
        const data = snapshot.val();
        const imageObjects = data ? Object.values(data) as ImageObject[] : [];
        if (import.meta.env.DEV) {
          console.log(`üñºÔ∏è Loaded ${imageObjects.length} image objects`);
        }
        set({ imageObjects });
        checkSuccess();
      }, (error) => {
        checkError('ImageObjects', error);
      });
      unsubscribeFunctions.push(unsubscribeImageObjects);
      
      // DrawObjects Î¶¨Ïä§ÎÑà  
      const drawObjectsRef = ref(database, 'drawObjects');
      const unsubscribeDrawObjects = onValue(drawObjectsRef, (snapshot) => {
        const { pendingBarrier } = get();
        if (pendingBarrier) return;
        const data = snapshot.val();
        const drawObjects = data ? Object.values(data) as DrawObject[] : [];
        if (import.meta.env.DEV) {
          console.log(`‚úèÔ∏è Loaded ${drawObjects.length} draw objects`);
        }
        set({ drawObjects });
        checkSuccess();
      }, (error) => {
        checkError('DrawObjects', error);
      });
      unsubscribeFunctions.push(unsubscribeDrawObjects);
      
      // FloorImage Î¶¨Ïä§ÎÑà
      const floorImageRef = ref(database, 'floorImage');
      const unsubscribeFloorImage = onValue(floorImageRef, (snapshot) => {
        const { pendingBarrier } = get();
        if (pendingBarrier) return;
        const floorImage = snapshot.val() as FloorImage | null;
        if (import.meta.env.DEV) {
          console.log(`üè† Loaded floor image: ${floorImage ? 'YES' : 'NO'}`);
        }
        set({ floorImage });
        checkSuccess();
      }, (error) => {
        checkError('FloorImage', error);
      });
      unsubscribeFunctions.push(unsubscribeFloorImage);
      
      // Settings Î¶¨Ïä§ÎÑà
      const settingsRef = ref(database, 'settings');
      const unsubscribeSettings = onValue(settingsRef, (snapshot) => {
        const { pendingBarrier } = get();
        if (pendingBarrier) return;
        const settings = snapshot.val() as Settings;
        if (settings) {
          set({ settings });
        }
        if (import.meta.env.DEV) {
          console.log(`‚öôÔ∏è Loaded settings`);
        }
        checkSuccess();
      }, (error) => {
        checkError('Settings', error);
      });
      unsubscribeFunctions.push(unsubscribeSettings);
    },
    
    cleanupFirebaseListeners: () => {
      unsubscribeFunctions.forEach(unsubscribe => unsubscribe());
      unsubscribeFunctions = [];
    },

    // Flush barrier: write current document state to DB with rev/session meta
    flushDocumentState: async (createSnapshot = false, onSnapshotCreated, skipFirebaseSync = false) => {
      const state = get();
      const nextRev = (state.serverRev || 0) + 1;
      const timestamp = Date.now();

      if (import.meta.env.DEV) {
        console.log(`üîÑ flushDocumentState ÏãúÏûë: textObjects=${state.textObjects.length}, imageObjects=${state.imageObjects.length}, skipFirebaseSync=${skipFirebaseSync}`);
      }

      let textObjectsToSave = state.textObjects;
      let imageObjectsToSave = state.imageObjects;

      // undo/redoÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå Firebase ÏÉÅÌÉú ÌôïÏù∏ (skipFirebaseSync = false)
      if (!skipFirebaseSync) {
        // FirebaseÏùò ÏµúÏã† ÏÉÅÌÉúÎ•º Î®ºÏ†Ä ÌôïÏù∏ÌïòÏó¨ Î©îÎ™®Î¶¨ÏôÄ ÎèôÍ∏∞Ìôî
        try {
          const [textSnapshot, imageSnapshot] = await Promise.all([
            firebaseGet(ref(database, 'textObjects')),
            firebaseGet(ref(database, 'imageObjects'))
          ]);

          const firebaseTextObjects = textSnapshot.val() ? Object.values(textSnapshot.val()) as TextObject[] : [];
          const firebaseImageObjects = imageSnapshot.val() ? Object.values(imageSnapshot.val()) as ImageObject[] : [];

          if (import.meta.env.DEV) {
            console.log(`üîç Firebase ÏµúÏã† ÏÉÅÌÉú: text=${firebaseTextObjects.length}, image=${firebaseImageObjects.length}`);
          }

          // Î©îÎ™®Î¶¨ ÏÉÅÌÉúÏôÄ Firebase ÏÉÅÌÉúÎ•º ÎèôÍ∏∞Ìôî (Firebase ÏÉÅÌÉúÎ•º Ïö∞ÏÑ†)
          textObjectsToSave = firebaseTextObjects.length > 0 ? firebaseTextObjects : state.textObjects;
          imageObjectsToSave = firebaseImageObjects.length > 0 ? firebaseImageObjects : state.imageObjects;

          // Î©îÎ™®Î¶¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (undo/redoÍ∞Ä ÏïÑÎãê ÎïåÎßå)
          set({
            textObjects: textObjectsToSave,
            imageObjects: imageObjectsToSave
          });

        } catch (error) {
          if (import.meta.env.DEV) {
            console.error('‚ùå Firebase ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®, Î©îÎ™®Î¶¨ ÏÉÅÌÉúÎ°ú ÏßÑÌñâ:', error);
          }
          // Firebase ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå® Ïãú Î©îÎ™®Î¶¨ ÏÉÅÌÉúÎ°ú ÏßÑÌñâ (fallback)
        }
      } else {
        if (import.meta.env.DEV) {
          console.log(`‚è≠Ô∏è Firebase ÏÉÅÌÉú ÌôïÏù∏ ÏÉùÎûµ (undo/redo Î™®Îìú)`);
        }
      }

      const rootUpdates: Record<string, any> = {};

      for (const obj of textObjectsToSave) {
        rootUpdates[`textObjects/${obj.id}`] = { ...obj };
      }
      for (const obj of imageObjectsToSave) {
        rootUpdates[`imageObjects/${obj.id}`] = { ...obj };
      }
      rootUpdates['floorImage'] = state.floorImage ?? null;
      rootUpdates['meta'] = { rev: nextRev, sessionId: state.sessionId, lastModifiedTs: timestamp };

      set({ pendingBarrier: true });
      const p = firebaseUpdate(ref(database), rootUpdates)
        .then(() => {
          set({ localRev: nextRev, serverRev: nextRev });
          // Create snapshot after successful DB update if requested
          if (createSnapshot && onSnapshotCreated) {
            onSnapshotCreated();
          }
        })
        .finally(() => {
          set({ pendingBarrier: false, lastFlushPromise: null });
        });
      set({ lastFlushPromise: p });
      await p;
    },
    
    addTextObject: async (obj) => {
      const textObjectsRef = ref(database, 'textObjects');
      const newRef = push(textObjectsRef);
      const sessionId = getCurrentSessionId();
      const newObj: TextObject = {
        ...obj,
        id: newRef.key!,
        lastModified: Date.now(),
        modifiedBy: sessionId
      };
      await firebaseSet(newRef, newObj);
      return newRef.key!; // ÏÉàÎ°ú ÏÉùÏÑ±Îêú Í∞ùÏ≤¥Ïùò ID Î∞òÌôò
    },
    
    addTextObjects: async (objects) => {
      if (objects.length === 0) return [];
      
      const textObjectsRef = ref(database, 'textObjects');
      const sessionId = getCurrentSessionId();
      const timestamp = Date.now();
      
      // Î™®Îì† Í∞ùÏ≤¥Ïóê ÎåÄÌï¥ Firebase keyÎ•º ÎØ∏Î¶¨ ÏÉùÏÑ±
      const newRefs = objects.map(() => push(textObjectsRef));
      const newObjects: TextObject[] = objects.map((obj, index) => ({
        ...obj,
        id: newRefs[index].key!,
        lastModified: timestamp,
        modifiedBy: sessionId
      }));
      
      // Firebase batch update (merge) - Î£®Ìä∏ÏóêÏÑú Í≤ΩÎ°ú Í∏∞Î∞ò ÏóÖÎç∞Ïù¥Ìä∏
      const updates: Record<string, TextObject> = {};
      newObjects.forEach((obj) => {
        updates[`textObjects/${obj.id}`] = obj;
      });
      await firebaseUpdate(ref(database), updates);
      
      // ÏÉùÏÑ±Îêú Î™®Îì† ID Î∞òÌôò
      return newObjects.map(obj => obj.id);
    },
    
    updateTextObject: async (id, updates) => {
      const validatedUpdates = validateFirebaseUpdate(updates);
      const success = await lwwUpdateTextObject(id, validatedUpdates);
      if (!success) {
        console.warn(`Failed to update text object ${id} due to LWW conflict`);
        // ÌïÑÏöîÏãú ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º ÌëúÏãú
      }
    },

    // Ïó¨Îü¨ TextObjectÎ•º Ìïú Î≤àÏùò ÎÑ§Ìä∏ÏõåÌÅ¨ Ìò∏Ï∂úÎ°ú Î≥ëÌï© ÏóÖÎç∞Ïù¥Ìä∏
    updateTextObjectsBatch: async (updatesById) => {
      const ids = Object.keys(updatesById);
      if (ids.length === 0) return;

      // Í≤ΩÎ°ú Í∏∞Î∞ò ÏóÖÎç∞Ïù¥Ìä∏ Í∞ùÏ≤¥ Íµ¨ÏÑ±
      const sessionId = getCurrentSessionId();
      const timestamp = Date.now();
      const rootUpdates: Record<string, any> = {};

      const flatten = (basePath: string, obj: any) => {
        Object.entries(obj).forEach(([key, value]) => {
          const path = `${basePath}/${key}`;
          if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
            flatten(path, value);
          } else {
            rootUpdates[path] = value;
          }
        });
      };

      for (const id of ids) {
        const validated = validateFirebaseUpdate(updatesById[id]);
        // Í∞úÎ≥Ñ ÌïÑÎìúÎì§Ïóê ÎåÄÌï¥ Í≤ΩÎ°ú Í∏∞Î∞òÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ Íµ¨ÏÑ±
        flatten(`textObjects/${id}`, { ...validated, lastModified: timestamp, modifiedBy: sessionId });
      }

      await firebaseUpdate(ref(database), rootUpdates);
    },
    
    deleteTextObject: async (id) => {
      const objectRef = ref(database, `textObjects/${id}`);
      await remove(objectRef);
    },
    
    deleteTextObjects: async (ids) => {
      if (ids.length === 0) return;
      
      if (ids.length === 1) {
        // Îã®Ïùº Í∞ùÏ≤¥Îäî Í∏∞Ï°¥ Ìï®Ïàò ÏÇ¨Ïö©
        await get().deleteTextObject(ids[0]);
        return;
      }
      
      // Firebase batch delete (merge) - Î£®Ìä∏ÏóêÏÑú Í≤ΩÎ°ú Í∏∞Î∞ò ÏÇ≠Ï†ú
      const updates: Record<string, null> = {};
      ids.forEach((id) => {
        updates[`textObjects/${id}`] = null; // Firebase updateÏóêÏÑú nullÏùÄ Ìï¥Îãπ Í≤ΩÎ°ú ÏÇ≠Ï†ú
      });
      await firebaseUpdate(ref(database), updates);
    },
    
    addImageObject: async (obj) => {
      const imageObjectsRef = ref(database, 'imageObjects');
      const newRef = push(imageObjectsRef);
      const sessionId = getCurrentSessionId();
      const newObj: ImageObject = {
        ...obj,
        id: newRef.key!,
        lastModified: Date.now(),
        modifiedBy: sessionId
      };
      await firebaseSet(newRef, newObj);
      return newRef.key!; // ÏÉàÎ°ú ÏÉùÏÑ±Îêú Í∞ùÏ≤¥Ïùò ID Î∞òÌôò
    },
    
    updateImageObject: async (id, updates) => {
      const validatedUpdates = validateFirebaseUpdate(updates);
      const success = await lwwUpdateImageObject(id, validatedUpdates);
      if (!success) {
        console.warn(`Failed to update image object ${id} due to LWW conflict`);
        // ÌïÑÏöîÏãú ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º ÌëúÏãú
      }
    },
    
    deleteImageObject: async (id) => {
      const objectRef = ref(database, `imageObjects/${id}`);
      await remove(objectRef);
    },
    
    deleteImageObjects: async (ids) => {
      if (ids.length === 0) return;
      
      if (ids.length === 1) {
        // Îã®Ïùº Í∞ùÏ≤¥Îäî Í∏∞Ï°¥ Ìï®Ïàò ÏÇ¨Ïö©
        await get().deleteImageObject(ids[0]);
        return;
      }
      
      // Firebase batch delete (merge) - Î£®Ìä∏ÏóêÏÑú Í≤ΩÎ°ú Í∏∞Î∞ò ÏÇ≠Ï†ú
      const updates: Record<string, null> = {};
      ids.forEach((id) => {
        updates[`imageObjects/${id}`] = null;
      });
      await firebaseUpdate(ref(database), updates);
    },
    
    deleteDrawObject: async (id) => {
      const objectRef = ref(database, `drawObjects/${id}`);
      await remove(objectRef);
    },
    
    setFloorImage: async (image) => {
      const floorImageRef = ref(database, 'floorImage');
      await firebaseSet(floorImageRef, image);
    },
    
    updateSettings: async (section, updates) => {
      const settingsRef = ref(database, `settings/${section}`);
      const currentSettings = get().settings[section];
      await firebaseSet(settingsRef, { ...currentSettings, ...updates });
    },

    // Ìå®Ïä§ÏõåÎìú Ï¥àÍ∏∞Ìôî (DBÎßå ÏÇ¨Ïö©, ÌôòÍ≤ΩÎ≥ÄÏàò ÏùòÏ°¥ÏÑ± Ï†úÍ±∞)
    initializePasswords: async () => {
      // Îçî Ïù¥ÏÉÅ ÌôòÍ≤ΩÎ≥ÄÏàòÎ•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå
      // DBÏóê Ìå®Ïä§ÏõåÎìúÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ÏóêÎßå Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      const currentState = get();
      const currentPasswords = currentState.settings.admin.passwords;
      
      if (import.meta.env.DEV) {
        console.log('üîë Password initialization: DB-only mode');
        console.log('üîë Current passwords:', currentPasswords);
      }
    },

    // Ìå®Ïä§ÏõåÎìú ÏóÖÎç∞Ïù¥Ìä∏
    updatePassword: async (type, newPassword) => {
      if (!newPassword || newPassword.length !== 4 || !/^\d{4}$/.test(newPassword)) {
        throw new Error('Ìå®Ïä§ÏõåÎìúÎäî 4ÏûêÎ¶¨ Ïà´ÏûêÏó¨Ïïº Ìï©ÎãàÎã§.');
      }

      const currentState = get();
      const currentPasswords = currentState.settings.admin.passwords;
      
      await get().updateSettings('admin', {
        passwords: {
          ...currentPasswords,
          [type]: newPassword
        }
      });

      if (import.meta.env.DEV) {
        console.log(`üîë ${type.toUpperCase()} password updated successfully`);
      }
    },

    // Ìå®Ïä§ÏõåÎìú Ï°∞Ìöå
    getPassword: (type) => {
      const currentState = get();
      return currentState.settings.admin.passwords[type] || '1004';
    },
  };
}); 